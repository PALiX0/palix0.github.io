<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ev_01 Overall Standings</title>
    <style>
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <h1>Ev_01 Overall Standings</h1>
    <p id="debugInfo"></p>
    <table id="standings">
        <thead>
            <tr>
                <th>Position</th>
                <th>Driver</th>
                <th>Total Time</th>
                <th>Time Difference to First</th>
                <th>Total Penalty</th>
                <th>Stages Completed</th>
                <th>Platform</th>
                <th>DNF</th>
                <th>Event Points</th>
                <th>Power Stage Points</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>

    <script>
        async function fetchCSV(url) {
            const response = await fetch(url);
            if (!response.ok) {
                console.error(`Failed to load CSV: ${url}`);
                return [];
            }
            const text = await response.text();
            return parseCSV(text);
        }

        function parseCSV(data) {
            const rows = data.split("\n").map(row => row.trim()).filter(row => row !== "");
            const headers = rows[0].split(",").map(header => header.trim());
            const dataRows = rows.slice(1);
            const rankIndex = headers.indexOf("Rank");
            const driverIndex = headers.indexOf("DisplayName");
            const timeIndex = headers.indexOf("Time");
            const platformIndex = headers.indexOf("Platform");
            const penaltyTimeIndex = headers.indexOf("TimePenalty");

            if (rankIndex === -1 || driverIndex === -1 || timeIndex === -1) {
                console.error("Required columns are missing from the CSV file.");
                return [];
            }

            return dataRows.map(row => {
                const cells = row.split(",").map(cell => cell.trim());
                return {
                    rank: parseInt(cells[rankIndex], 10),
                    driver: cells[driverIndex],
                    time: cells[timeIndex],
                    penaltyTime: penaltyTimeIndex !== -1 ? cells[penaltyTimeIndex] : "00:00:00.000", // Default if missing
                    platform: cells[platformIndex] || "Unknown"
                };
            }).filter(row => row.rank && row.driver && row.time);
        }
function isTerminalDamageTime(time) {
    const terminalDamageTimes = ["00:08:00", "00:16:00", "00:25:00"];
    return terminalDamageTimes.includes(time.trim());
}
        
function parseTimeToSeconds(time) {
    if (!time || typeof time !== "string") {
        console.warn(`Invalid time value: "${time}"`);
        return 0;
    }

    // Ensure the time string matches the expected format
    const timeRegex = /^(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?$/;
    const matches = time.match(timeRegex);

    if (!matches) {
        console.warn(`Unexpected time format: "${time}"`);
        return 0;
    }

    const [hh, mm, ss, ms = "0"] = matches.slice(1);

    // If milliseconds are not provided, default to 0
    return (
        parseInt(hh, 10) * 3600 +
        parseInt(mm, 10) * 60 +
        parseInt(ss, 10) +
        parseFloat(`0.${ms}`)
    );
}


        function formatSecondsToTime(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = (totalSeconds % 60).toFixed(3);
            return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(6, "0")}`;
        }

        async function listCSVFiles() {
            try {
                const response = await fetch("/RALLYLTU_WRC/csv/Ch_W05/Ev_01/file_list.json");
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const files = await response.json();
                document.getElementById("debugInfo").innerText = `Found ${files.length} CSV file(s).`;
                return files.map(file => `/RALLYLTU_WRC/csv/Ch_W05/Ev_01/${file}`);
            } catch (error) {
                document.getElementById("debugInfo").innerText = `Error loading file list: ${error.message}`;
                console.error("Error loading file_list.json:", error);
                return [];
            }
        }

        async function fetchPointsMap() {
            const response = await fetch("/points/points_top20.csv");
            if (!response.ok) {
                console.error("Failed to load points map.");
                return {};
            }
            const text = await response.text();
            return text.split("\n").reduce((map, line) => {
                const [position, points] = line.split(",").map(x => parseInt(x, 10));
                if (!isNaN(position) && !isNaN(points)) {
                    map[position] = points;
                }
                return map;
            }, {});
        }

async function generateStandings() {
    const files = await listCSVFiles();
    const pointsMap = await fetchPointsMap();
    const standings = {};
    const lastStageResults = await fetchCSV(files[files.length - 1]);
    const powerStagePoints = [5, 4, 3, 2, 1];

    // Process each stage file
    for (const file of files) {
        const stageResults = await fetchCSV(file);
stageResults.forEach(({ rank, driver, time, platform, penaltyTime }) => {
    const totalSeconds = parseTimeToSeconds(time);
    const penaltySeconds = penaltyTime ? parseTimeToSeconds(penaltyTime) : 0;

    // Ensure driver data exists in standings
    if (!standings[driver]) {
        standings[driver] = {
            totalTime: 0,
            penaltyTime: 0,
            stagesCompleted: 0,
            dnf: false,
            platform,
        };
    }

    const driverData = standings[driver];

    if (isTerminalDamageTime(time)) {
        // Handle terminal damage case
        driverData.totalTime += totalSeconds; // Add the terminal damage time
        driverData.dnf = true; // Mark driver as DNF
    //    driverData.penaltyTime += penaltySeconds; // Include any penalties from the CSV
        driverData.stagesCompleted += 1; // Count as a completed stage
    } else {
        // Normal case: add time and penalties
        driverData.totalTime += totalSeconds;
        driverData.penaltyTime += penaltySeconds;
        driverData.stagesCompleted += 1;
    }
});
    }

// Apply penalties for missed stages
const totalStages = files.length;
for (const driver in standings) {
    const data = standings[driver];
    const missedStages = totalStages - data.stagesCompleted;

    if (missedStages > 0) {
        const missedPenalty = missedStages * 1800; // 30 minutes per missed stage
        data.penaltyTime += missedPenalty; // Add missed stage penalty
        data.dnf = true; // Mark as DNF if stages are missed
    }
}

    // Sort standings, keeping DNFs at the bottom
    let sortedStandings = Object.entries(standings)
    .sort(([, a], [, b]) => {
        if (a.dnf && b.dnf) {
            // Both are DNFs: sort by total time
            return (a.totalTime + a.penaltyTime) - (b.totalTime + b.penaltyTime);
        }
        if (a.dnf) return 1; // Move DNFs to the bottom
        if (b.dnf) return -1; // Move DNFs to the bottom
        // Both are not DNFs: sort by total time
        return (a.totalTime + a.penaltyTime) - (b.totalTime + b.penaltyTime);
    });

    // Get the best total time to calculate time difference to first
    const bestTotalTime = sortedStandings.find(([, data]) => !data.dnf)?.[1]?.totalTime || 0;

    // Map driver data to standings
    sortedStandings = sortedStandings.map(([driver, data], index) => ({
        position: index + 1,
        driver,
        totalTime: formatSecondsToTime(data.totalTime + data.penaltyTime),
        timeDiff: data.dnf
            ? formatSecondsToTime(data.totalTime + data.penaltyTime - bestTotalTime)
            : formatSecondsToTime(data.totalTime + data.penaltyTime - bestTotalTime),
        totalPenalty: formatSecondsToTime(data.penaltyTime),
        stagesCompleted: data.stagesCompleted,
        platform: data.platform,
        dnf: data.dnf ? "DNF" : "",
        eventPoints: data.dnf ? 0 : pointsMap[index + 1] || 0,
        powerStagePoints: lastStageResults.find(r => r.driver === driver)?.rank <= 5
            ? powerStagePoints[lastStageResults.find(r => r.driver === driver).rank - 1]
            : 0
    }));

    // Render standings in the table
    const tbody = document.querySelector("#standings tbody");
    tbody.innerHTML = "";
    sortedStandings.forEach(({ position, driver, totalTime, timeDiff, totalPenalty, stagesCompleted, platform, dnf, eventPoints, powerStagePoints }) => {
        const row = `<tr>
            <td>${position}</td>
            <td>${driver}</td>
            <td>${totalTime}</td>
            <td>${timeDiff}</td>
            <td>${totalPenalty}</td>
            <td>${stagesCompleted}</td>
            <td>${platform}</td>
            <td>${dnf}</td>
            <td>${eventPoints}</td>
            <td>${powerStagePoints}</td>
        </tr>`;
        tbody.innerHTML += row;
    });
}


        async function main() {
            await generateStandings();
        }

        main();
    </script>
</body>
</html>
