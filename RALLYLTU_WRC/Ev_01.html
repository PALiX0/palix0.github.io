<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ev_01 Overall Standings</title>
    <style>
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <h1>Ev_01 Overall Standings</h1>
    <p id="debugInfo"></p>
    <table id="standings">
        <thead>
            <tr>
                <th>Power Stage Points</th>
                <th>Event Points</th>
                <th>Position</th>
                <th>Driver</th>
                <th>Total Time</th>
                <th>Time Difference to First</th>
                <th>Total Time Penalty</th>
                <th>DNF</th>
                <th>Stages Completed</th>
                <th>Platform</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>

    <script>
        async function fetchJSON(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch JSON: ${url}`);
            }
            return response.json();
        }

        async function fetchBannedPlayers() {
          const response = await fetchJSON("/banned_players.json");
          return new Set(response); // Convert to Set for faster lookup
        }

        async function fetchCSV(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch CSV: ${url}`);
            }
            return response.text();
        }

        function parseCSV(data) {
            const rows = data.split("\n").map(row => row.trim()).filter(row => row);
            const headers = rows[0].split(",").map(header => header.trim());
            const dataRows = rows.slice(1);

            // Dynamic index mapping
            const rankIndex = headers.indexOf("Rank");
            const driverIndex = headers.indexOf("DisplayName");
            const timeIndex = headers.indexOf("Time");
            const penaltyIndex = headers.indexOf("TimePenalty");
            const platformIndex = headers.indexOf("Platform");

            return dataRows.map(row => {
                const cells = row.split(",").map(cell => cell.trim());
                return {
                    rank: parseInt(cells[rankIndex], 10),
                    driver: cells[driverIndex],
                    time: cells[timeIndex],
                    penalty: parseTimeToSeconds(cells[penaltyIndex] || "00:00:00"),
                    platform: cells[platformIndex],
                };
            });
        }

        function parseTimeToSeconds(time) {
            const [hh, mm, ssWithMs] = time.split(":");
            const [ss, ms = "0"] = ssWithMs.split(".");
            return (
                parseInt(hh, 10) * 3600 +
                parseInt(mm, 10) * 60 +
                parseInt(ss, 10) +
                parseFloat(`0.${ms}`)
            );
        }

        function formatSecondsToTime(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = (totalSeconds % 60).toFixed(3);
            return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(6, "0")}`;
        }

        async function fetchPoints() {
            const pointsData = await fetchCSV("/points/points_top20.csv");
            return pointsData.split("\n").reduce((pointsMap, row) => {
                const [position, points] = row.split(",").map(Number);
                pointsMap[position] = points;
                return pointsMap;
            }, {});
        }

        async function listCSVFiles() {
            const fileList = await fetchJSON("/RALLYLTU_WRC/csv/Ch_W05/Ev_01/file_list.json");
            return fileList.map(file => `/RALLYLTU_WRC/csv/Ch_W05/Ev_01/${file}`);
        }

        async function generateStandings() {
            const bannedPlayers = await fetchBannedPlayers();
            const files = await listCSVFiles();
            const pointsMap = await fetchPoints();
            const standings = {};
            let lastStageResults = [];

            for (const [index, file] of files.entries()) {
                const csvData = await fetchCSV(file);
                const stageResults = parseCSV(csvData);

                if (index === files.length - 1) lastStageResults = stageResults;

stageResults.forEach(({ position, driver, time, platform }) => {
    const totalSeconds = parseTimeToSeconds(time);

    // Initialize driver data if not already present
    if (!standings[driver]) {
        standings[driver] = {
            totalTime: 0,
            penaltyTime: 0,
            stagesCompleted: 0,
            missedStages: 0,
            platform,
            dnf: false, // Default to not DNF
        };
    }

    const driverData = standings[driver];

    // Add stage time and increment completed stages
    driverData.totalTime += totalSeconds;
    driverData.stagesCompleted += 1;
});
            }
            
// Check for missed stages and apply penalties
for (const driver in standings) {
    const driverData = standings[driver];
    const missedStages = files.length - driverData.stagesCompleted;

    if (missedStages > 0) {
        driverData.penaltyTime += missedStages * 30 * 60; // Add 30 minutes per missed stage
        driverData.dnf = true; // Mark as DNF
    }
}

// Sort standings with DNFs at the bottom
const sortedStandings = Object.entries(standings)
    .sort(([, a], [, b]) => {
        if (a.dnf && b.dnf) return 0; // Keep relative order of DNFs
        if (a.dnf) return 1; // DNF goes to the bottom
        if (b.dnf) return -1; // Valid goes above
        return (a.totalTime + a.penaltyTime) - (b.totalTime + b.penaltyTime);
    })
    .map(([driver, data], index) => ({
        position: data.dnf ? "-" : index + 1,
        driver,
        totalTime: data.dnf ? "DNF" : formatSecondsToTime(data.totalTime),
        timeDiff: data.dnf ? "-" : formatSecondsToTime(data.totalTime - sortedStandings[0][1].totalTime),
        totalPenalty: formatSecondsToTime(data.penaltyTime),
        stagesCompleted: data.stagesCompleted,
        platform: data.platform,
        dnf: data.dnf ? "DNF" : "",
        eventPoints: data.dnf ? 0 : pointsMap[index + 1] || 0, // No points for DNF
    }));
            
            // Add timeDiff in a second pass
            const baseTime = sortedStandings.find(entry => entry.position !== "-")?.rawTotalTime || 0;
            
            sortedStandings.forEach(entry => {
                if (entry.position !== "-") {
                    entry.timeDiff = formatSecondsToTime(entry.rawTotalTime - baseTime);
                } else {
                    entry.timeDiff = "-";
                }
            });

            const lastStagePowerPoints = lastStageResults.slice(0, 5).map((result, i) => ({
                driver: result.driver,
                powerStagePoints: 5 - i,
            }));

            const tbody = document.querySelector("#standings tbody");
            tbody.innerHTML = "";
            sortedStandings.forEach(({ powerStagePoints, eventPoints, position, driver, totalTime, timeDiff, totalPenalty, dnf, stagesCompleted, platform }) => {
                const row = `<tr>
                    <td>${powerStagePoints || 0}</td>
                    <td>${eventPoints}</td>
                    <td>${position}</td>
                    <td>${driver}</td>
                    <td>${totalTime}</td>
                    <td>${timeDiff}</td>
                    <td>${totalPenalty}</td>
                    <td>${dnf}</td>
                    <td>${stagesCompleted}</td>
                    <td>${platform}</td>
                </tr>`;
                tbody.innerHTML += row;
            });
        }

        async function main() {
            await generateStandings();
        }

        main();
    </script>
</body>
</html>
